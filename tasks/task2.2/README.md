<h2 align="center">
    2 <i><b>Составить самое большое число</b></i> 2
</h2>

> **_Пояснение_**

Нужно было что-то получше _based_ пузырька и желательно в 1 строчку :)

В функции _main_ присутствует _input()_ (хотя он не нужен), потому что в примерах ввода сначала вводится число _n_, а потом строчка чисел _numbers_.

Сплитим полученную строчку чисел в список. Далее - сортируем этот список чисел (числа в строковом формате) согласно функции _compare_ (2 числа (_n1_, _n2_) сравниваются по их суммам: _n1+n2_, _n2+n1_). Но такую функцию нельзя передать в _key_, поэтому используется функция _cmp_to_key_, которая преобразует _cmp=_ функцию в _key=_ функцию (так как _cmp_ больше нет в _python3_). После чего, объединяем все в строчку (с разделителем _sep_, который по умолчанию равен пустой строке) и возвращаем ее.

_p.s._ Сначала пытался сделать другим способом:

    def largest_number_old(numbers: str, sep: str = '') -> str:
        return sep.join(sorted(numbers.split(), key=lambda x: x + x[-1] * (4 - len(x)), reverse=True))

Но была выявлена ошибка: "73 733" вернет "73733", потому что считалось, что 73 равен 733 (дописывался ласт символ), после этого решил сменить подход.

_p.s.s_ В файле _test.py_ представлен небольшой набор тестовых значений, который использовался для выявления багов (да, можно было прикрутить unittest, но камон, в следующий раз :D). Для удобства числа выводятся через пробел.
